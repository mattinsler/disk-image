
const __imports = {};

__imports['metro-memory-fs'] = (function(module){
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */
"use strict";
/* eslint-disable no-bitwise */
// $FlowFixMe: not defined by Flow

const constants = require("constants");

const stream = require("stream");

const { EventEmitter } = require("events");

const kWritableMustExist = Symbol("kWritableMustExist");
const FLAGS_SPECS = {
  r: {
    mustExist: true,
    readable: true
  },
  "r+": {
    mustExist: true,
    readable: true,
    writable: true
  },
  "rs+": {
    mustExist: true,
    readable: true,
    writable: true
  },
  w: {
    truncate: true,
    writable: true
  },
  wx: {
    exclusive: true,
    truncate: true,
    writable: true
  },
  "w+": {
    readable: true,
    truncate: true,
    writable: true
  },
  "wx+": {
    exclusive: true,
    readable: true,
    truncate: true,
    writable: true
  },
  // $FlowIssue: Symbol support is incomplete
  [kWritableMustExist]: {
    mustExist: true,
    writable: true
  }
};
const ASYNC_FUNC_NAMES = [
  "access",
  "chmod",
  "close",
  "copyFile",
  "fchmod",
  "fstat",
  "fsync",
  "fdatasync",
  "lchmod",
  "link",
  "lstat",
  "mkdir",
  "mkdtemp",
  "open",
  "read",
  "readdir",
  "readFile",
  "readlink",
  "realpath",
  "rename",
  "stat",
  "truncate",
  "unlink",
  "write",
  "writeFile"
];
const NATIVE_FUNC_NAMES = ["realpath", "realpathSync"]; // Generated by `node -p "Object.keys(require('fs').promises).sort()"`

const PROMISE_FUNC_NAMES = [
  "access",
  "appendFile",
  "chmod",
  "chown",
  "copyFile",
  "lchmod",
  "lchown",
  "link",
  "lstat",
  "mkdir",
  "mkdtemp",
  "open",
  "readFile",
  "readdir",
  "readlink",
  "realpath",
  "rename",
  "rmdir",
  "stat",
  "symlink",
  "truncate",
  "unlink",
  "utimes",
  "writeFile"
];

/**
 * Simulates `fs` API in an isolated, memory-based filesystem. This is useful
 * for testing systems that rely on `fs` without affecting the real filesystem.
 * This is meant to be a drop-in replacement/mock for `fs`, so it mimics
 * closely the behavior of file path resolution and file accesses.
 */
class MemoryFs {
  constants = constants;
  Dirent = Dirent;

  constructor(options) {
    this._platform = (options && options.platform) || "posix";
    this._cwd = options && options.cwd;
    this._pathSep = this._platform === "win32" ? "\\" : "/";
    this.reset();
    ASYNC_FUNC_NAMES.forEach(funcName => {
      const func = this[`${funcName}Sync`];

      this[funcName] = function(...args) {
        const callback = args.pop();
        process.nextTick(() => {
          let retval;

          try {
            retval = func.apply(null, args);
          } catch (error) {
            callback(error);
            return;
          }

          callback(null, retval);
        });
      };
    });
    NATIVE_FUNC_NAMES.forEach(funcName => {
      const func = this[funcName];
      func.native = func;
    });
    this.promises = PROMISE_FUNC_NAMES.filter(
      // $FlowFixMe: No indexer
      funcName => typeof this[`${funcName}Sync`] === "function"
    ).reduce((promises, funcName) => {
      promises[funcName] = (...args) =>
        new Promise((resolve, reject) => {
          try {
            // $FlowFixMe: No indexer
            resolve(this[`${funcName}Sync`](...args));
          } catch (error) {
            reject(error);
          }
        });

      return promises;
    }, {});
  }

  reset() {
    this._nextId = 1;
    this._roots = new Map();

    if (this._platform === "posix") {
      this._roots.set("", this._makeDir(0o777));
    } else if (this._platform === "win32") {
      this._roots.set("C:", this._makeDir(0o777));
    }

    this._fds = new Map();
  }

  accessSync = (filePath, mode) => {
    if (mode == null) {
      mode = constants.F_OK;
    }

    const stats = this.statSync(filePath);

    if (mode == constants.F_OK) {
      return;
    }

    const filePathStr = pathStr(filePath);

    if ((mode & constants.R_OK) !== 0) {
      if (
        !(
          (stats.mode & constants.S_IROTH) !== 0 ||
          ((stats.mode & constants.S_IRGRP) !== 0 && stats.gid === getgid()) ||
          ((stats.mode & constants.S_IRUSR) !== 0 && stats.uid === getuid())
        )
      ) {
        throw makeError("EPERM", filePathStr, "file cannot be read");
      }
    }

    if ((mode & constants.W_OK) !== 0) {
      if (
        !(
          (stats.mode & constants.S_IWOTH) !== 0 ||
          ((stats.mode & constants.S_IWGRP) !== 0 && stats.gid === getgid()) ||
          ((stats.mode & constants.S_IWUSR) !== 0 && stats.uid === getuid())
        )
      ) {
        throw makeError("EPERM", filePathStr, "file cannot be written to");
      }
    }

    if ((mode & constants.X_OK) !== 0) {
      if (
        !(
          (stats.mode & constants.S_IXOTH) !== 0 ||
          ((stats.mode & constants.S_IXGRP) !== 0 && stats.gid === getgid()) ||
          ((stats.mode & constants.S_IXUSR) !== 0 && stats.uid === getuid())
        )
      ) {
        throw makeError("EPERM", filePathStr, "file cannot be executed");
      }
    }
  };
  chmodSync = (filePath, mode) => {
    filePath = pathStr(filePath);
    mode = parseFileMode(mode);

    const { node } = this._resolve(filePath);

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    node.mode = mode;
  };
  closeSync = fd => {
    const desc = this._getDesc(fd);

    if (desc.writable) {
      this._emitFileChange(desc.nodePath.slice(), {
        eventType: "change"
      });
    }

    this._fds.delete(fd);
  };
  copyFileSync = (src, dest, flags = 0) => {
    const options =
      flags & constants.COPYFILE_EXCL
        ? {
            flag: "wx"
          }
        : {};
    this.writeFileSync(dest, this.readFileSync(src), options);
  };
  fchmodSync = (fd, mode) => {
    mode = parseFileMode(mode);

    const { node } = this._getDesc(fd);

    node.mode = mode;
  };
  fsyncSync = fd => {
    this._getDesc(fd);
  };
  fdatasyncSync = fd => {
    this._getDesc(fd);
  };
  lchmodSync = (filePath, mode) => {
    filePath = pathStr(filePath);
    mode = parseFileMode(mode);

    const { node } = this._resolve(filePath, {
      keepFinalSymlink: true
    });

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    node.mode = mode;
  };
  openSync = (filePath, flags, mode) => {
    if (typeof flags === "number") {
      throw new Error(`numeric flags not supported: ${flags}`);
    }

    return this._open(pathStr(filePath), flags, mode);
  };
  readSync = (fd, buffer, offset, length, position) => {
    const desc = this._getDesc(fd);

    if (!desc.readable) {
      throw makeError("EBADF", null, "file descriptor cannot be written to");
    }

    if (position != null) {
      desc.position = position;
    }

    const endPos = Math.min(desc.position + length, desc.node.content.length);
    desc.node.content.copy(buffer, offset, desc.position, endPos);
    const bytesRead = endPos - desc.position;
    desc.position = endPos;
    return bytesRead;
  };
  readdirSync = (filePath, options) => {
    let encoding, withFileTypes;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ encoding, withFileTypes } = options);
    }

    filePath = pathStr(filePath);

    const { node } = this._resolve(filePath);

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    if (node.type !== "directory") {
      throw makeError("ENOTDIR", filePath, "not a directory");
    }

    return Array.from(node.entries.keys()).map(str => {
      let name;

      if (encoding === "utf8") {
        name = str;
      } else {
        const buffer = Buffer.from(str);

        if (encoding === "buffer") {
          name = buffer;
        } else {
          name = buffer.toString(encoding);
        }
      }

      if (withFileTypes) {
        return new Dirent(nullthrows(node.entries.get(str)), name);
      }

      return name;
    });
  };
  readFileSync = (filePath, options) => {
    let encoding, flag;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ encoding, flag } = options);
    }

    const fd = this._open(pathStr(filePath), flag || "r");

    const chunks = [];

    try {
      const buffer = Buffer.alloc(1024);
      let bytesRead;

      do {
        bytesRead = this.readSync(fd, buffer, 0, buffer.length, null);

        if (bytesRead === 0) {
          continue;
        }

        const chunk = Buffer.alloc(bytesRead);
        buffer.copy(chunk, 0, 0, bytesRead);
        chunks.push(chunk);
      } while (bytesRead > 0);
    } finally {
      this.closeSync(fd);
    }

    const result = Buffer.concat(chunks);

    if (encoding == null) {
      return result;
    }

    return result.toString(encoding);
  };
  readlinkSync = (filePath, options) => {
    let encoding;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ encoding } = options);
    }

    filePath = pathStr(filePath);

    const { node } = this._resolve(filePath, {
      keepFinalSymlink: true
    });

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    if (node.type !== "symbolicLink") {
      throw makeError("EINVAL", filePath, "entity is not a symlink");
    }

    if (encoding == null || encoding === "utf8") {
      return node.target;
    }

    const buf = Buffer.from(node.target);

    if (encoding == "buffer") {
      return buf;
    }

    return buf.toString(encoding);
  };
  realpathSync = filePath => {
    return this._resolve(pathStr(filePath)).realpath;
  };
  writeSync = (
    fd,
    bufferOrString,
    offsetOrPosition,
    lengthOrEncoding,
    position
  ) => {
    let encoding, offset, length, buffer;

    if (typeof bufferOrString === "string") {
      position = offsetOrPosition;
      encoding = lengthOrEncoding;
      buffer = Buffer.from(bufferOrString, encoding || "utf8");
    } else {
      offset = offsetOrPosition;

      if (lengthOrEncoding != null && typeof lengthOrEncoding !== "number") {
        throw new Error("invalid length");
      }

      length = lengthOrEncoding;
      buffer = bufferOrString;
    }

    if (offset == null) {
      offset = 0;
    }

    if (length == null) {
      length = buffer.length;
    }

    return this._write(fd, buffer, offset, length, position);
  };
  writeFileSync = (filePathOrFd, data, options) => {
    let encoding, mode, flag;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ encoding, mode, flag } = options);
    }

    if (encoding == null) {
      encoding = "utf8";
    }

    if (typeof data === "string") {
      data = Buffer.from(data, encoding);
    }

    const fd =
      typeof filePathOrFd === "number"
        ? filePathOrFd
        : this._open(pathStr(filePathOrFd), flag || "w", mode);

    try {
      this._write(fd, data, 0, data.length);
    } finally {
      if (typeof filePathOrFd !== "number") {
        this.closeSync(fd);
      }
    }
  };
  mkdirSync = (dirPath, mode) => {
    if (mode == null) {
      mode = 0o777;
    }

    dirPath = pathStr(dirPath);

    const { dirNode, node, basename } = this._resolve(dirPath);

    if (node != null) {
      throw makeError("EEXIST", dirPath, "directory or file already exists");
    }

    dirNode.entries.set(basename, this._makeDir(mode));
  };
  mkdtempSync = (prefix, options) => {
    var _ref;

    const encoding =
      (_ref =
        typeof options === "string"
          ? options
          : options === null || options === void 0
          ? void 0
          : options.encoding) !== null && _ref !== void 0
        ? _ref
        : "utf8";
    const ALPHABET =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
    const RANDOM_PART_LENGTH = 6;
    let dirPath = "";

    do {
      let randomPart = "";

      for (let i = 0; i < RANDOM_PART_LENGTH; ++i) {
        randomPart += ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
      }

      dirPath = prefix + randomPart;
    } while (this.existsSync(dirPath));

    this.mkdirSync(dirPath, 0o700);
    return Buffer.from(dirPath, "utf8").toString(encoding);
  };
  rmdirSync = dirPath => {
    dirPath = pathStr(dirPath);

    const { dirNode, node, basename } = this._resolve(dirPath);

    if (node == null) {
      throw makeError("ENOENT", dirPath, "directory does not exist");
    } else if (node.type === "file") {
      if (this._platform === "posix") {
        throw makeError("ENOTDIR", dirPath, "cannot rm a file");
      } else {
        throw makeError("ENOENT", dirPath, "cannot rm a file");
      }
    } else if (node.type === "directory" && node.entries.size) {
      throw makeError("ENOTEMPTY", dirPath, "directory not empty");
    }

    dirNode.entries.delete(basename);
  };
  symlinkSync = (target, filePath, type) => {
    if (type == null) {
      type = "file";
    }

    if (type !== "file") {
      throw new Error("symlink type not supported");
    }

    filePath = pathStr(filePath);

    const { dirNode, node, basename } = this._resolve(filePath);

    if (node != null) {
      throw makeError("EEXIST", filePath, "directory or file already exists");
    }

    dirNode.entries.set(basename, {
      id: this._getId(),
      gid: getgid(),
      target: pathStr(target),
      mode: 0o666,
      uid: getuid(),
      type: "symbolicLink",
      watchers: []
    });
  };
  existsSync = filePath => {
    try {
      const { node } = this._resolve(pathStr(filePath));

      return node != null;
    } catch (error) {
      if (error.code === "ENOENT") {
        return false;
      }

      throw error;
    }
  };
  statSync = filePath => {
    filePath = pathStr(filePath);

    const { node } = this._resolve(filePath);

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    return new Stats(node);
  };
  lstatSync = filePath => {
    filePath = pathStr(filePath);

    const { node } = this._resolve(filePath, {
      keepFinalSymlink: true
    });

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    return new Stats(node);
  };
  fstatSync = fd => {
    const desc = this._getDesc(fd);

    return new Stats(desc.node);
  };
  createReadStream = (filePath, options) => {
    let autoClose, encoding, fd, flags, mode, start, end, highWaterMark;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ autoClose, encoding, fd, flags, mode, start } = options);
      ({ end, highWaterMark } = options);
    }

    let st = null;

    if (fd == null) {
      fd = this._open(pathStr(filePath), flags || "r", mode);
      process.nextTick(() => st.emit("open", fd));
    }

    const ffd = fd;
    const { readSync } = this;
    const ropt = {
      filePath,
      encoding,
      fd,
      highWaterMark,
      start,
      end,
      readSync
    };
    const rst = new ReadFileSteam(ropt);
    st = rst;

    if (autoClose !== false) {
      const doClose = () => {
        this.closeSync(ffd);
        rst.emit("close");
      };

      rst.on("end", doClose);
      rst.on("error", doClose);
    }

    return rst;
  };
  unlinkSync = filePath => {
    filePath = pathStr(filePath);

    const { basename, dirNode, dirPath, node } = this._resolve(filePath, {
      keepFinalSymlink: true
    });

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    if (node.type !== "file" && node.type !== "symbolicLink") {
      throw makeError("EISDIR", filePath, "cannot unlink a directory");
    }

    dirNode.entries.delete(basename);

    this._emitFileChange(dirPath.concat([[basename, node]]), {
      eventType: "rename"
    });
  };
  renameSync = (oldPath, newPath) => {
    oldPath = pathStr(oldPath);
    newPath = pathStr(newPath);

    const {
      basename: oldBasename,
      dirNode: oldDirNode,
      dirPath: oldDirPath,
      node: node
    } = this._resolve(oldPath, {
      keepFinalSymlink: true
    });

    if (node == null) {
      throw makeError("ENOENT", oldPath, "no such file or directory");
    }

    const {
      basename: newBasename,
      dirNode: newDirNode,
      dirPath: newDirPath,
      node: existingDestNode
    } = this._resolve(newPath, {
      keepFinalSymlink: true
    });

    if (existingDestNode === node) {
      return;
    }

    if (newDirPath.some(([, nodeInNewPath]) => nodeInNewPath === node)) {
      throw makeError(
        "EINVAL",
        newPath,
        "cannot make a directory a subdirectory of itself"
      );
    }

    if (existingDestNode) {
      if (existingDestNode.type === "directory") {
        if (existingDestNode.entries.size) {
          throw makeError("ENOTEMPTY", newPath, "directory not empty");
        }
      } else if (node.type === "directory") {
        throw makeError(
          "EISDIR",
          newPath,
          "cannot overwrite a directory with a non-directory"
        );
      }
    }

    newDirNode.entries.set(newBasename, node);

    if (existingDestNode) {
      // The existing node has been removed.
      this._emitFileChange(
        newDirPath.concat([[newBasename, existingDestNode]]),
        {
          eventType: "rename"
        }
      );
    } // The source node has been linked at the new path.

    this._emitFileChange(newDirPath.concat([[newBasename, node]]), {
      eventType: "rename"
    });

    oldDirNode.entries.delete(oldBasename); // The source node has been unlinked at the old path.

    this._emitFileChange(oldDirPath.concat([[oldBasename, node]]), {
      eventType: "rename"
    });
  };
  linkSync = (oldPath, newPath) => {
    oldPath = pathStr(oldPath);
    newPath = pathStr(newPath);

    const { node: node } = this._resolve(oldPath);

    if (node == null) {
      throw makeError("ENOENT", oldPath, "no such file or directory");
    }

    if (node.type === "directory") {
      throw makeError(
        "EPERM",
        oldPath,
        "cannot create a hard link to a directory"
      );
    }

    const {
      basename: newBasename,
      dirNode: newDirNode,
      dirPath: newDirPath,
      node: existingDestNode
    } = this._resolve(newPath);

    if (existingDestNode) {
      throw makeError("EEXIST", newPath, "destination path already exists");
    }

    newDirNode.entries.set(newBasename, node);

    this._emitFileChange(newDirPath.concat([[newBasename, node]]), {
      eventType: "rename"
    });
  };
  truncateSync = (filePathOrFd, length = 0) => {
    const fd =
      typeof filePathOrFd === "number"
        ? filePathOrFd
        : this._open(pathStr(filePathOrFd), kWritableMustExist);

    try {
      const desc = this._getDesc(fd);

      if (!desc.writable) {
        throw makeError("EBADF", null, "file descriptor cannot be written to");
      }

      const { node, nodePath } = desc;
      const oldContent = node.content;
      node.content = Buffer.alloc(length, 0);
      oldContent.copy(
        node.content,
        0,
        0,
        Math.max(0, Math.min(length, oldContent.length))
      );

      this._emitFileChange(nodePath.slice(), {
        eventType: "change"
      });
    } finally {
      if (typeof filePathOrFd !== "number") {
        this.closeSync(fd);
      }
    }
  };
  createWriteStream = (filePath, options) => {
    var _emitClose;

    let autoClose, fd, flags, mode, start, emitClose;

    if (typeof options !== "string" && options != null) {
      ({ autoClose, fd, flags, mode, start, emitClose } = options);
    }

    let st = null;

    if (fd == null) {
      fd = this._open(pathStr(filePath), flags || "w", mode);
      process.nextTick(() => st.emit("open", fd));
    }

    const ffd = fd;
    const ropt = {
      fd,
      writeSync: this._write.bind(this),
      filePath,
      start,
      emitClose:
        (_emitClose = emitClose) !== null && _emitClose !== void 0
          ? _emitClose
          : false
    };
    const rst = new WriteFileStream(ropt);
    st = rst;

    if (autoClose !== false) {
      const doClose = () => {
        this.closeSync(ffd);
      };

      rst.on("finish", doClose);
      rst.on("error", doClose);
    }

    return st;
  };
  watch = (filePath, options, listener) => {
    filePath = pathStr(filePath);

    const { node } = this._resolve(filePath);

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    let encoding, recursive, persistent;

    if (typeof options === "string") {
      encoding = options;
    } else if (options != null) {
      ({ encoding, recursive, persistent } = options);
    }

    const watcher = new FSWatcher(node, {
      encoding: encoding != null ? encoding : "utf8",
      recursive: recursive != null ? recursive : false,
      persistent: persistent != null ? persistent : false
    });

    if (listener != null) {
      watcher.on("change", listener);
    }

    return watcher;
  };

  _makeDir(mode) {
    return {
      entries: new Map(),
      gid: getgid(),
      id: this._getId(),
      mode,
      uid: getuid(),
      type: "directory",
      watchers: []
    };
  }

  _getId() {
    return ++this._nextId;
  }

  _open(filePath, flags, mode) {
    if (mode == null) {
      mode = 0o666;
    }

    const spec = FLAGS_SPECS[flags];

    if (spec == null) {
      throw new Error(`flags not supported: \`${flags.toString()}\``);
    }

    const { writable = false, readable = false } = spec;
    const { exclusive, mustExist, truncate } = spec;

    let { dirNode, node, basename, dirPath } = this._resolve(filePath);

    let nodePath;

    if (node == null) {
      if (mustExist) {
        throw makeError("ENOENT", filePath, "no such file or directory");
      }

      node = {
        content: Buffer.alloc(0),
        gid: getgid(),
        id: this._getId(),
        mode,
        uid: getuid(),
        type: "file",
        watchers: []
      };
      dirNode.entries.set(basename, node);
      nodePath = dirPath.concat([[basename, node]]);

      this._emitFileChange(nodePath.slice(), {
        eventType: "rename"
      });
    } else {
      if (exclusive) {
        throw makeError("EEXIST", filePath, "directory or file already exists");
      }

      if (node.type !== "file") {
        throw makeError("EISDIR", filePath, "cannot read/write to a directory");
      }

      if (truncate) {
        node.content = Buffer.alloc(0);
      }

      nodePath = dirPath.concat([[basename, node]]);
    }

    return this._getFd(filePath, {
      nodePath,
      node,
      position: 0,
      readable,
      writable
    });
  }

  _parsePath(filePath) {
    let drive;
    const sep = this._platform === "win32" ? /[\\/]/ : /\//;

    if (this._platform === "win32" && filePath.match(/^[a-zA-Z]:[\\/]/)) {
      drive = filePath.substring(0, 2);
      filePath = filePath.substring(3);
    }

    if (sep.test(filePath[0])) {
      if (this._platform === "posix") {
        drive = "";
        filePath = filePath.substring(1);
      } else {
        throw makeError(
          "EINVAL",
          filePath,
          "path is invalid because it cannot start with a separator"
        );
      }
    }

    return {
      entNames: filePath.split(sep),
      drive
    };
  }
  /**
   * Implemented according with
   * http://man7.org/linux/man-pages/man7/path_resolution.7.html
   */

  _resolve(filePath, options) {
    let keepFinalSymlink = false;

    if (options != null) {
      ({ keepFinalSymlink } = options);
    }

    if (filePath === "") {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    let { drive, entNames } = this._parsePath(filePath);

    if (drive == null) {
      const { _cwd } = this;

      if (_cwd == null) {
        throw new Error(
          `The path \`${filePath}\` cannot be resolved because no ` +
            "current working directory function has been specified. Set the " +
            "`cwd` option field to specify a current working directory."
        );
      }

      const cwPath = this._parsePath(_cwd());

      drive = cwPath.drive;

      if (drive == null) {
        throw new Error(
          "On a win32 FS, the options' `cwd()` must return a valid win32 " +
            "absolute path. This happened while trying to " +
            `resolve: \`${filePath}\``
        );
      }

      entNames = cwPath.entNames.concat(entNames);
    }

    checkPathLength(entNames, filePath);

    const root = this._getRoot(drive, filePath);

    const context = {
      drive,
      node: root,
      nodePath: [["", root]],
      entNames,
      symlinkCount: 0,
      keepFinalSymlink
    };

    while (context.entNames.length > 0) {
      const entName = context.entNames.shift();

      this._resolveEnt(context, filePath, entName);
    }

    const { nodePath } = context;
    return {
      drive: context.drive,
      realpath: context.drive + nodePath.map(x => x[0]).join(this._pathSep),
      dirNode: (() => {
        const dirNode =
          nodePath.length >= 2
            ? nodePath[nodePath.length - 2][1]
            : context.node;

        if (dirNode == null || dirNode.type !== "directory") {
          throw new Error("failed to resolve");
        }

        return dirNode;
      })(),
      node: context.node,
      basename: nullthrows(nodePath[nodePath.length - 1][0]),
      dirPath: nodePath
        .slice(0, -1)
        .map(nodePair => [nodePair[0], nullthrows(nodePair[1])])
    };
  }

  _resolveEnt(context, filePath, entName) {
    const { node } = context;

    if (node == null) {
      throw makeError("ENOENT", filePath, "no such file or directory");
    }

    if (node.type !== "directory") {
      throw makeError("ENOTDIR", filePath, "not a directory");
    }

    const { entries } = node;

    if (entName === "" || entName === ".") {
      return;
    }

    if (entName === "..") {
      const { nodePath } = context;

      if (nodePath.length > 1) {
        nodePath.pop();
        context.node = nodePath[nodePath.length - 1][1];
      }

      return;
    }

    const childNode = entries.get(entName);

    if (
      childNode == null ||
      childNode.type !== "symbolicLink" ||
      (context.keepFinalSymlink && context.entNames.length === 0)
    ) {
      context.node = childNode;
      context.nodePath.push([entName, childNode]);
      return;
    }

    if (context.symlinkCount >= 10) {
      throw makeError("ELOOP", filePath, "too many levels of symbolic links");
    }

    const { entNames, drive } = this._parsePath(childNode.target);

    if (drive != null) {
      context.drive = drive;
      context.node = this._getRoot(drive, filePath);
      context.nodePath = [["", context.node]];
    }

    context.entNames = entNames.concat(context.entNames);
    checkPathLength(context.entNames, filePath);
    ++context.symlinkCount;
  }

  _getRoot(drive, filePath) {
    const root = this._roots.get(drive.toUpperCase());

    if (root == null) {
      throw makeError("ENOENT", filePath, `no such drive: \`${drive}\``);
    }

    return root;
  }

  _write(fd, buffer, offset, length, position) {
    const desc = this._getDesc(fd);

    if (!desc.writable) {
      throw makeError("EBADF", null, "file descriptor cannot be written to");
    }

    if (position == null) {
      position = desc.position;
    }

    const { node } = desc;

    if (node.content.length < position + length) {
      const newBuffer = Buffer.alloc(position + length);
      node.content.copy(newBuffer, 0, 0, node.content.length);
      node.content = newBuffer;
    }

    buffer.copy(node.content, position, offset, offset + length);
    desc.position = position + length;
    return buffer.length;
  }

  _getFd(filePath, desc) {
    let fd = 3;

    while (this._fds.has(fd)) {
      ++fd;
    }

    if (fd >= 256) {
      throw makeError("EMFILE", filePath, "too many open files");
    }

    this._fds.set(fd, desc);

    return fd;
  }

  _getDesc(fd) {
    const desc = this._fds.get(fd);

    if (desc == null) {
      throw makeError("EBADF", null, "file descriptor is not open");
    }

    return desc;
  }

  _emitFileChange(nodePath, options) {
    const fileNode = nodePath.pop();
    let filePath = fileNode[0];
    let recursive = false;

    for (const watcher of fileNode[1].watchers) {
      watcher.listener(options.eventType, filePath);
    }

    while (nodePath.length > 0) {
      const dirNode = nodePath.pop();

      for (const watcher of dirNode[1].watchers) {
        if (recursive && !watcher.recursive) {
          continue;
        }

        watcher.listener(options.eventType, filePath);
      }

      filePath = dirNode[0] + this._pathSep + filePath;
      recursive = true;
    }
  }
}

class Stats {
  /**
   * Don't keep a reference to the node as it may get mutated over time.
   */
  constructor(node) {
    this._type = node.type;
    this.dev = 1;
    this.mode = node.mode;
    this.nlink = 1;
    this.uid = node.uid;
    this.gid = node.gid;
    this.rdev = 0;
    this.blksize = 1024;
    this.ino = node.id;
    this.size =
      node.type === "file"
        ? node.content.length
        : node.type === "symbolicLink"
        ? node.target.length
        : 0;
    this.blocks = Math.ceil(this.size / 512);
    this.atimeMs = 1;
    this.mtimeMs = 1;
    this.ctimeMs = 1;
    this.birthtimeMs = 1;
    this.atime = new Date(this.atimeMs);
    this.mtime = new Date(this.mtimeMs);
    this.ctime = new Date(this.ctimeMs);
    this.birthtime = new Date(this.birthtimeMs);
  }

  isFile() {
    return this._type === "file";
  }

  isDirectory() {
    return this._type === "directory";
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isSymbolicLink() {
    return this._type === "symbolicLink";
  }

  isFIFO() {
    return false;
  }

  isSocket() {
    return false;
  }
}

class ReadFileSteam extends stream.Readable {
  constructor(options) {
    const { highWaterMark, fd } = options;
    const superOptions =
      highWaterMark != null
        ? {
            highWaterMark
          }
        : {};
    super(superOptions);
    this.bytesRead = 0;
    this.path = options.filePath;
    this._readSync = options.readSync;
    this._fd = fd;
    this._buffer = Buffer.alloc(1024);
    const { start, end } = options;

    if (start != null) {
      this._readSync(fd, Buffer.alloc(0), 0, 0, start);
    }

    if (end != null) {
      this._positions = {
        current: start || 0,
        last: end + 1
      };
    }
  }

  _read(size) {
    let bytesRead;
    const { _buffer } = this;

    do {
      const length = this._getLengthToRead();

      const position = this._positions && this._positions.current;
      bytesRead = this._readSync(this._fd, _buffer, 0, length, position);

      if (this._positions != null) {
        this._positions.current += bytesRead;
      }

      this.bytesRead += bytesRead;
    } while (this.push(bytesRead > 0 ? _buffer.slice(0, bytesRead) : null));
  }

  _getLengthToRead() {
    const { _positions, _buffer } = this;

    if (_positions == null) {
      return _buffer.length;
    }

    const leftToRead = Math.max(0, _positions.last - _positions.current);
    return Math.min(_buffer.length, leftToRead);
  }
}

class WriteFileStream extends stream.Writable {
  constructor(opts) {
    super({
      emitClose: opts.emitClose,
      autoDestroy: true
    });
    this.path = opts.filePath;
    this.bytesWritten = 0;
    this._fd = opts.fd;
    this._writeSync = opts.writeSync;

    if (opts.start != null) {
      this._writeSync(opts.fd, Buffer.alloc(0), 0, 0, opts.start);
    }
  }

  _write(buffer, encoding, callback) {
    try {
      const bytesWritten = this._writeSync(this._fd, buffer, 0, buffer.length);

      this.bytesWritten += bytesWritten;
    } catch (error) {
      callback(error);
      return;
    }

    callback();
  }
}

class FSWatcher extends EventEmitter {
  constructor(node, options) {
    super();
    this._encoding = options.encoding;
    this._nodeWatcher = {
      recursive: options.recursive,
      listener: this._listener
    };
    node.watchers.push(this._nodeWatcher);
    this._node = node;

    if (options.persistent) {
      this._persistIntervalId = setInterval(() => {}, 60000);
    }
  }

  close() {
    this._node.watchers.splice(this._node.watchers.indexOf(this._nodeWatcher));

    clearInterval(this._persistIntervalId);
  }

  _listener = (eventType, filePath) => {
    const encFilePath =
      this._encoding === "buffer" ? Buffer.from(filePath, "utf8") : filePath;

    try {
      this.emit("change", eventType, encFilePath);
    } catch (error) {
      this.close();
      this.emit("error", error);
    }
  };
}

class Dirent {
  /**
   * Don't keep a reference to the node as it may get mutated over time.
   */
  constructor(node, name) {
    this._stats = new Stats(node);
    this.name = name;
  }

  isBlockDevice() {
    return this._stats.isBlockDevice();
  }

  isCharacterDevice() {
    return this._stats.isCharacterDevice();
  }

  isDirectory() {
    return this._stats.isDirectory();
  }

  isFIFO() {
    return this._stats.isFIFO();
  }

  isFile() {
    return this._stats.isFile();
  }

  isSocket() {
    return this._stats.isSocket();
  }

  isSymbolicLink() {
    return this._stats.isSymbolicLink();
  }
}

function checkPathLength(entNames, filePath) {
  if (entNames.length > 32) {
    throw makeError(
      "ENAMETOOLONG",
      filePath,
      "file path too long (or one of the intermediate " +
        "symbolic link resolutions)"
    );
  }
}

function pathStr(filePath) {
  if (typeof filePath === "string") {
    return filePath;
  }

  return filePath.toString("utf8");
}

function makeError(code, filePath, message) {
  const err = new Error(
    filePath != null
      ? `${code}: \`${filePath}\`: ${message}`
      : `${code}: ${message}`
  );
  err.code = code;
  err.errno = constants[code];
  err.path = filePath;
  return err;
}

function nullthrows(x) {
  if (x == null) {
    throw new Error("item was null or undefined");
  }

  return x;
}

function getgid() {
  return process.getgid != null ? process.getgid() : -1;
}

function getuid() {
  return process.getuid != null ? process.getuid() : -1;
}

function parseFileMode(mode) {
  if (typeof mode === "string") {
    return Number.parseInt(mode, 8);
  }

  return mode;
}

module.exports = MemoryFs;

return module;
})({}).exports;

(function(require){
const fs = require('fs');
const v8 = require('v8');
const path = require('path');
const zlib = require('zlib');
const { Module } = require('module');
const MemoryFs = require('metro-memory-fs');

function log(...args) {
  if (!!process.env.DEBUG) {
    console.log(...args);
  }
}

// copyFile, copyFileSync ==> (src, dest)
// link, linkSync ==> (existingPath, newPath)
// rename, renameSync ==> (oldPath, newPath)
// symlink, symlinkSync ==> (target, path)

const SRC_DEST_MEHTODS = new Set([
  'copyFile',
  'copyFileSync',
  'link',
  'linkSync',
  'rename',
  'renameSync',
  'symlink',
  'symlinkSync',
]);

const FILE_DESCRIPTOR_METHODS = new Set([
  'close',
  'closeSync',
  'fchmod',
  'fchmodSync',
  'fchown',
  'fchownSync',
  'fdatasync',
  'fdatasyncSync',
  'fstat',
  'fstatSync',
  'fsync',
  'fsyncSync',
  'ftruncate',
  'ftruncateSync',
  'futimes',
  'futimesSync',
  'read',
  'readSync',
  'readv',
  'readvSync',
  'write',
  'writeSync',
  'writev',
  'writevSync',
]);

function patchModule(memfs, serveDirectories) {
  const directoriesToServe = [...serveDirectories].sort();

  function resolveFile(file) {
    log(`resolveFile(${file})`);
    if (memfs.existsSync(file) && !memfs.statSync(file).isDirectory()) {
      return file;
    }
    return false;
  }

  function resolveFileWithExtensions(file) {
    return [file, `${file}.js`, path.join(file, 'index.js')].find(resolveFile) || false;
  }

  function resolve(file) {
    const pkgJsonFile = path.join(file, 'package.json');
    if (memfs.existsSync(pkgJsonFile)) {
      const { main } = JSON.parse(memfs.readFileSync(pkgJsonFile, 'utf8'));
      if (main) {
        return resolveFileWithExtensions(path.join(file, main));
      } else {
        return resolveFile(path.join(file, 'index.js'));
      }
    }

    return resolveFileWithExtensions(file);
  }

  Module._findPath = function (request, paths, isMain) {
    log(`_findPath(${request}, ${paths}, ${isMain})`);

    if (path.isAbsolute(request)) {
      return resolve(request);
    } else {
      for (let x = 0; x < paths.length; ++x) {
        const res = resolve(path.join(paths[x], request));
        if (res) {
          return res;
        }
      }
    }

    return false;
  };

  function isServed(file) {
    log(`isServed(${file})`);
    return directoriesToServe.findIndex((dir) => file.startsWith(dir)) !== -1;
  }

  const originalfs = {};
  Object.keys(memfs).forEach((key) => {
    originalfs[key] = fs[key];

    fs[key] = (...args) => {
      log(key, args);

      if (FILE_DESCRIPTOR_METHODS.has(key)) {
        if (memfs._fds.has(args[0])) {
          return memfs[key].apply(memfs, args);
        } else {
          return originalfs[key].apply(originalfs, args);
        }
      } else if (SRC_DEST_MEHTODS.has(key)) {
        const srcIsServed = isServed(args[0]);
        const destIsServed = isServed(args[1]);
        if (srcIsServed !== destIsServed) {
          throw new Error(
            `Cannot handle fs methods where the src and dest are not either both within the served directories or both outside the served directories: ${args[0]} => ${args[1]}.`
          );
        }
        if (srcIsServed) {
          return memfs[key].apply(memfs, args);
        } else {
          return originalfs[key].apply(originalfs, args);
        }
      } else {
        if (isServed(args[0])) {
          return memfs[key].apply(memfs, args);
        } else {
          return originalfs[key].apply(originalfs, args);
        }
      }
    };
  });
}

if (process.argv.length < 4) {
  console.error('Usage: node run-disk-image.js DISK_IMAGE ENTRYPOINT');
  process.exit(1);
}

const diskImageFile = process.argv[2];
const entrypoint = process.argv[3];

if (!fs.existsSync(diskImageFile)) {
  throw new Error(`Disk image file ${diskImageFile} does not exist.`);
}

const { roots, serve } = v8.deserialize(zlib.gunzipSync(fs.readFileSync(diskImageFile)));
const memfs = new MemoryFs({ cwd: () => process.cwd(), platform: 'posix' });
memfs._roots = roots;
patchModule(memfs, serve);
Module._load(entrypoint, undefined, true);

})(function(request) {
  return __imports[request] || require(request);
});

